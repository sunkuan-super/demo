# 发布订阅模式
    解读：
    
    1个生产者，多个消费者
    每一个消费者都有自己的一个队列
    生产者没有将消息直接发送到队列，而是发送到了交换机 exchange
    每个队列都要绑定到交换机
    生产者发送的消息，经过交换机，到达队列，实现一个消息被多个消费者获取的目的
    
# 路由模式
    交换机：
    
    1、一方面是接收生产者的消息，另一方面是向队列中推送消息
    
    2、类别
        匿名转发  ""
        
        fanout（不处理路由键）  所有绑定的队列都能接收到消息
                
        direct(处理路由键)     绑定的队列中匹配的才能接收到消息

# RabbitMQ的消息确认机制（事务+confirm）
    在rabbitmq中，我们可以通过持久化数据，解决rabbitmq服务器异常的数据丢失问题。

    问题：生产者将消息发送出去之后，消息到底有没有到达rabbitmq服务器，默认情况是不知道的;
    
    两种方式：
        AMQP实现了事务机制
        Confirm模式
    

## 一、事务机制
    txSelect txCommit txRollback
    
    txSelect: 用户将当前channel设置成transtion模式
    txCommit: 用于提交事务
    txRollback: 回滚事务 
    
    这种模式耗时，采用这种方式降低了rabbitmq的消息吞吐量
    
## 二、Confirm模式
### 1、生产者
    confirm模式最大的好处在于他是异步的
    Nack
    
    开启Confirm模式
    channel.confirmSelect()
    编程模式：
        1.普通: 发一条 waitForConfirms
        2.批量的: 发一批 waitForConfirms
        3.异步confirm模式: 提供一个回调方法 
        
# RabbitMQ应用场景
    1、异步处理
        同步变异步：用之前，主程序项目在运行过程中调用其他项目，且必须等待返回结果后主程序才做下一步操作；用之后，主程序发送执行信息后继续执行自己的代码，不用等待其他程序执行结果。
        
        同步：需要等待调用结果后主程序在进行下一步操作。
        eg:用户注册成功后将注册信息写入数据库后还需要给用户发短信和发邮件两个操作。同步方式就是写入数据库后，紧接着给用户发短信，发完短信再给用户发邮件。直到这些步骤全部执行完才
           给用户反馈注册成功。
        异步：不用等待调用结果，主程序立刻进行下一步操作。
        eg:用户注册成功后将注册信息写入数据库后还需要给用户发短信和发邮件两个操作。异步方式就是写入数据库后，直接写消息队列（设置了持久化）。然后给用户反馈注册成功。
    2、应用解耦
        实现了主程序与其他程序的解耦合，不需要在主程序中直接调用其他程序，而是通过RabbitMQ将调用信息发送给其他程序即可。
        
        场景：
            双11购物狂欢节,用户下单成功后，订单系统需要通知库存系统，传统的做法就是订单系统调用库存系统的接口。这样有一个缺点：当库存系统出现故障时，订单就会失败。订单系统和库存
            系统高耦合，引入消息队列
            
            · 订单系统：用户下单成功后，订单系统完成持久化处理。将消息写入消息队列，返回用户订单下单成功
            · 库存系统：订阅下单的消息，获取下单消息，进行库操作。计算库存出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失。
    3、流量削峰
        秒杀活动，一般会因为流量过大，应用系统配置承载不了这股瞬间流量，导致系统直接挂掉，即传说中的“宕机”现象。为解决这个问题，我们会将那股巨大的流量拒在系统的上层，即将其转移至 
        MQ 而不直接涌入我们的接口，此时MQ起到了缓冲作用。
        
        场景：
            秒杀活动，一般会因为流量过大，导致应用挂掉，为解决这个问题，一般应用前端加入消息队列
        作用：
            1、可以控制活动人数，超过一定阈值的订单直接丢弃（我为什么秒杀一次都没有成功过呢）
            2、可以缓解短时间的高流量压垮应用（应用程序按自己的最大处理能力获取订单）        
    
        1、用户的请求，服务器收到之后，首先写入消息队列，加入消息队列长度超过最大值，则直接抛弃用户请求或跳转到错误页面
        2、秒杀业务根据消息队列中的请求信息，再做后续处理
        
# RabbitMQ的集群
## 1、集群架构
### （1）普通集群（副本集群）
    默认情况下：rabbitmq代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是队列，队列位于一个节点上，尽管它们可以从所有节点看到和访问
    
    核心解决的问题：当集群中某一时刻master节点宕机，可以对Queue中信息，进行备份。
### （2）镜像集群
    镜像队列机制就是将队列在3个节点之间设置主从关系，消息会在3个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群整体高可用性。